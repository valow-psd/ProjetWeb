{"ast":null,"code":"export default myaxios;\nimport axios from 'axios';\n\n// create a special axiosAgent agent that works with the apidemo API\nconst axiosAgent = axios.create({\n  baseURL: 'https://apidemo.iut-bm.univ-fcomte.frherocorp'\n});\naxiosAgent.interceptors.request.use(config => {\n  return {\n    ...config,\n    headers: {\n      'app-key': 'ceci est la clef secret'\n    }\n  };\n}, error => {\n  return Promise.reject(error);\n});\naxiosAgent.interceptors.response.use(res => {\n  console.log(\"OK => \" + JSON.stringify(res));\n  return res;\n}, error => {\n  console.log(\"ERROR => \" + JSON.stringify(error));\n  return Promise.reject(error);\n});\nfunction handleError(serviceName, err) {\n  if (err.response) {\n    // la requête a été reçue par le serveur mais celui-ci renvoie un status != 2XX, ce qui signifie\n    // une erreur. Par exemple, il peut renovyer un status 404 pour dire que la ressource demandée n'existe pas.\n    console.log(\"ERROR while calling SERVICE \" + serviceName + \": \" + JSON.stringify(err.response));\n    return {\n      data: {\n        error: 1,\n        data: err.response.data\n      }\n    }; // pass the whole object from server because it contains a data field too.\n  } else if (err.request) {\n    // la requete a été envoyée mais aucune réponse reçue.\n    console.log(\"NETWORK ERROR while calling SERVICE \" + serviceName + \": \" + JSON.stringify(err.request));\n    return {\n      data: {\n        error: 1,\n        data: 'Le serveur est injoignable ou l\\'URL demandée n\\'existe pas'\n      }\n    };\n  } else {\n    // tout autre cas\n    console.log(\"UNKNOWN ERROR while calling SERVICE \" + serviceName);\n    return {\n      data: {\n        error: 1,\n        data: 'Erreur inconnue'\n      }\n    };\n  }\n}\n\n/* Fonctions génériques pour envoyer des requêtes http\r\n\r\nNB: si tout va bien, un appel à axiosAgent renvoie un objet représentant la réponse à la requête à l'API\r\nCet objet est souvent nommé response et contient différents champs. Celui qui contient les données que renvoie l'API est nommé data.\r\nDans le cas de l'API apidemo, elle renvoie toujours des données au format {error: ..., data: ...}\r\nresponse.data.error indique donc si l'API a rencontré une erreur lors du traitement de la requête (par ex, insertion en BdD impossible)\r\nresponse.data.data contient les données réelles renvoyée par l'API, c.a.d. pour cette fonction un tableau contenant les personnages.\r\n */\n\n// NB: name est un \"surnom\" au service pour les message de debug\nasync function getRequest(service, name) {\n  let response = null;\n  try {\n    response = await axiosAgent.get(service);\n  } catch (err) {\n    // le catch se fait si le serveur répond avec une erreur type 4XX, 5XX, ou bien si le serveur est off\n    // dans ce cas, on appelle la méthode pour traiter ces types d'erreurs\n    response = handleError(name, err);\n  }\n  return response.data;\n}\n\n// NB: pour une requête post/patch, les données associées à la requête sont transmises\n// par axios sous la forme d'un objet JSON contenant ces données, et axios les transmet\n// de façon compactée dans le \"corps\" de la requête (c.a.d. la partie body). Du côté serveur, il faut \"analyser\"\n// le corps (donc utiliser le module body-parser) afin d'avoir le contenu de l'objet dans req.body.\n// Dans la méthode ci-dessous, le paramètre data correspond à l'objet JSON\nasync function postRequest(service, data, name) {\n  let response = null;\n  try {\n    response = await axiosAgent.post(service, data);\n  } catch (err) {\n    // le catch se fait si le serveur répond avec une erreur type 4XX, 5XX, ou bien si le serveur est off\n    // dans ce cas, on appelle la méthode pour traiter ces types d'erreurs\n    response = handleError(name, err);\n  }\n  return response.data;\n}\nasync function patchRequest(service, data, name) {\n  let response = null;\n  try {\n    response = await axiosAgent.patch(service, data);\n  } catch (err) {\n    // le catch se fait si le serveur répond avec une erreur type 4XX, 5XX, ou bien si le serveur est off\n    // dans ce cas, on appelle la méthode pour traiter ces types d'erreurs\n    response = handleError(name, err);\n  }\n  return response.data;\n}\nexport { getRequest, postRequest, patchRequest };","map":{"version":3,"names":["myaxios","axios","axiosAgent","create","baseURL","interceptors","request","use","config","headers","error","Promise","reject","response","res","console","log","JSON","stringify","handleError","serviceName","err","data","getRequest","service","name","get","postRequest","post","patchRequest","patch"],"sources":["C:/Users/valys/Documents/S4/Web/ProjetWeb/projet/src/service/axios.service.js"],"sourcesContent":["export default myaxios\r\n\r\nimport axios from 'axios'\r\n\r\n// create a special axiosAgent agent that works with the apidemo API\r\nconst axiosAgent = axios.create({\r\n  baseURL: 'https://apidemo.iut-bm.univ-fcomte.frherocorp'\r\n});\r\n\r\naxiosAgent.interceptors.request.use(\r\n    config => {\r\n      return { ...config, headers: { 'app-key': 'ceci est la clef secret'} }\r\n    },\r\n    error => {\r\n      return Promise.reject(error)\r\n    }\r\n)\r\n\r\naxiosAgent.interceptors.response.use(\r\n    res => {\r\n      console.log(\"OK => \"+JSON.stringify(res))\r\n      return res\r\n    },\r\n    error => {\r\n      console.log(\"ERROR => \"+JSON.stringify(error))\r\n      return Promise.reject(error)\r\n    }\r\n)\r\n\r\nfunction handleError(serviceName, err) {\r\n  if (err.response) {\r\n    // la requête a été reçue par le serveur mais celui-ci renvoie un status != 2XX, ce qui signifie\r\n    // une erreur. Par exemple, il peut renovyer un status 404 pour dire que la ressource demandée n'existe pas.\r\n    console.log(\"ERROR while calling SERVICE \" + serviceName + \": \" + JSON.stringify(err.response));\r\n    return {\r\n      data: {\r\n        error: 1,\r\n        data: err.response.data\r\n      }\r\n\r\n    }; // pass the whole object from server because it contains a data field too.\r\n  }\r\n  else if (err.request) {\r\n    // la requete a été envoyée mais aucune réponse reçue.\r\n    console.log(\"NETWORK ERROR while calling SERVICE \"+serviceName+ \": \" + JSON.stringify(err.request));\r\n    return {\r\n      data: {\r\n        error: 1,\r\n        data: 'Le serveur est injoignable ou l\\'URL demandée n\\'existe pas'\r\n      }\r\n    };\r\n  }\r\n  else {\r\n    // tout autre cas\r\n    console.log(\"UNKNOWN ERROR while calling SERVICE \"+serviceName);\r\n    return {\r\n      data: {\r\n        error: 1,\r\n        data: 'Erreur inconnue'\r\n      }\r\n    };\r\n  }\r\n}\r\n\r\n/* Fonctions génériques pour envoyer des requêtes http\r\n\r\nNB: si tout va bien, un appel à axiosAgent renvoie un objet représentant la réponse à la requête à l'API\r\nCet objet est souvent nommé response et contient différents champs. Celui qui contient les données que renvoie l'API est nommé data.\r\nDans le cas de l'API apidemo, elle renvoie toujours des données au format {error: ..., data: ...}\r\nresponse.data.error indique donc si l'API a rencontré une erreur lors du traitement de la requête (par ex, insertion en BdD impossible)\r\nresponse.data.data contient les données réelles renvoyée par l'API, c.a.d. pour cette fonction un tableau contenant les personnages.\r\n */\r\n\r\n// NB: name est un \"surnom\" au service pour les message de debug\r\nasync function getRequest(service, name) {\r\n  let response = null\r\n  try {\r\n    response = await axiosAgent.get(service)\r\n  } catch (err) {\r\n    // le catch se fait si le serveur répond avec une erreur type 4XX, 5XX, ou bien si le serveur est off\r\n    // dans ce cas, on appelle la méthode pour traiter ces types d'erreurs\r\n    response = handleError(name, err);\r\n  }\r\n  return response.data;\r\n}\r\n\r\n// NB: pour une requête post/patch, les données associées à la requête sont transmises\r\n// par axios sous la forme d'un objet JSON contenant ces données, et axios les transmet\r\n// de façon compactée dans le \"corps\" de la requête (c.a.d. la partie body). Du côté serveur, il faut \"analyser\"\r\n// le corps (donc utiliser le module body-parser) afin d'avoir le contenu de l'objet dans req.body.\r\n// Dans la méthode ci-dessous, le paramètre data correspond à l'objet JSON\r\nasync function postRequest(service, data, name) {\r\n  let response = null\r\n  try {\r\n    response = await axiosAgent.post(service, data)\r\n  } catch (err) {\r\n    // le catch se fait si le serveur répond avec une erreur type 4XX, 5XX, ou bien si le serveur est off\r\n    // dans ce cas, on appelle la méthode pour traiter ces types d'erreurs\r\n    response = handleError(name, err);\r\n  }\r\n  return response.data;\r\n}\r\n\r\nasync function patchRequest(service, data, name) {\r\n  let response = null\r\n  try {\r\n    response = await axiosAgent.patch(service, data)\r\n  } catch (err) {\r\n    // le catch se fait si le serveur répond avec une erreur type 4XX, 5XX, ou bien si le serveur est off\r\n    // dans ce cas, on appelle la méthode pour traiter ces types d'erreurs\r\n    response = handleError(name, err);\r\n  }\r\n  return response.data;\r\n}\r\n\r\nexport {\r\n  getRequest,\r\n  postRequest,\r\n  patchRequest,\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}